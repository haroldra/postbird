{
  "name": "any-db-transaction",
  "version": "0.0.1",
  "description": "Transaction object for Any-DB adapters",
  "main": "transaction.js",
  "dependencies": {
    "inherits": "~2.0.1",
    "yafsm": "0.0.0"
  },
  "devDependencies": {},
  "scripts": {
    "test": "node test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/grncdr/node-any-db-transaction.git"
  },
  "keywords": [
    "any-db",
    "transaction",
    "sql"
  ],
  "author": {
    "name": "Stephen Sugden",
    "email": "me@stephensugden.com"
  },
  "license": "BSD-2-Clause",
  "bugs": {
    "url": "https://github.com/grncdr/node-any-db-transaction/issues"
  },
  "readme": "# any-db-transaction\n\n*note:* Generally you will not want to use this package directly, it is primarily\nintended to simplify writing an Any-DB adapter that supports transactions.\n\n## Description\n\nTransaction objects are created by [Connection.begin][] and [Pool.begin][]. They\nare simple wrappers around a [Connection][] that implement the same API, but\nensure that all queries take place within a single database transaction.\n\nAny queries that error during a transaction will cause an automatic rollback. If\na query has no callback, the transaction will also handle (and re-emit)\n`'error'` events for that query. This enables handling errors for an entire\ntransaction in a single place.\n\nTransactions also implement their own [begin method][] for creating nested\ntransactions using savepoints. Nested transaction can safely error and rollback\nwithout rolling back their parent transaction.\n\n## API\n\n```ocaml\nTransaction := StateMachine & {\n  adapter:  String\n  query:    (String, Array?, Continuation<ResultSet>) => Query\n  begin:    (String?, Continuation<Transaction>) => Transaction\n  commit:   (Continuation?) => void\n  rollback: (Continuation?) => void\n}\n```\n\n### Transaction.adapter\n\nContains the adapter name used for the transaction, e.g. `'sqlite3'`, etc.\n\n### Transaction states\n\nTransactions are finite state machines with 4 states: `disconnected`,\n`connected`, `open`, and `closed`:\n\n    [disconnected]\n          ↓\n     [connected]\n       ↓  ↓  ↑\n       ↓ [open]\n       ↓   ↓\n      [closed]\n\nEvery transaction starts out in the `disconnected` state, in which it will queue\nall tasks (queries, child transactions, commits and rollbacks) in the order they\nare received.\n\nOnce the transaction acquires a connection\\* it will transition to the\n`connected` state and begin processing it's internal task queue. While in this\nstate any new tasks will still be added to the end of the queue. There are two\npossible transitions from the `connected` state:\n\n * `connected → open` - When all queued tasks have finished.\n * `connected → closed` - When a rollback or commit is encountered in the queue.\n   This includes automatic rollbacks caused by query errors.\n\n`closed` is a terminal state in which all further database operations result in\nerrors. (The errors will either be sent to any callback provided or emitted as\n`error` events on the next tick).\n\nIn the `open` state, all database operations will be performed immediately. If\na child transaction is started with [Transaction.begin][], the parent\ntransaction will move back into the `connected` state (queueing any queries it\nreceives) until the child completes, at which point it will resume processing\nit's own internal queue.\n\n*\\ * - Transactions started from [Connection.begin][] transition\nto `connected` before the transaction is returned from `.begin`.*\n\n### Transaction.query\n\n```ocaml\n(text: String, params: Array?, Continuation<Result>?) => Query\n```\n\nActs exactly like [Connection.query][] except queries are\nguaranteed to be performed within the transaction. If the transaction has been\ncommitted or rolled back further calls to `query` will fail.\n\n### Transaction.commit\n\n```ocaml\n(Continuation<void>) => void\n```\n\nIssue a `COMMIT` (or `RELEASE ...` in the case of nested transactions) statement\nto the database. If a callback is given it will be called with any errors after\nthe `COMMIT` statement completes. The transaction object itself will be unusable\nafter calling `commit()`.\n\n### Transaction.rollback\n\n```ocaml\n(Continuation<void>) => void\n```\n\nThe same as [Transaction.commit](#transactioncommit) but issues a `ROLLBACK`.\nAgain, the transaction will be unusable after calling this method.\n\n### Transaction.begin\n\n`(Continuation<void>) => void`\n\nStarts a nested transaction (by creating a savepoint) within this transaction\nand returns a new transaction object. Unlike [Connection.begin][], there is no\noption to replace the statement used to begin the transaction, this is because\nthe statement must use a known savepoint name.\n\nWhile the child transaction is in progress the parent transaction will queue any\nqueries it receives until the child transaction either commits or rolls back, at\nwhich point it will process the queue. Be careful: it's quite possible to write\ncode that deadlocks by waiting for a query in the parent transaction before\ncommitting the child transaction. For example:\n\n    // Do not do this! it won't work!\n\n    var parent = conn.begin();  // starts the transaction\n    var child = parent.begin(); // creates a savepoint\n\n    parent.query('SELECT 1', function (err) {\n      child.commit();\n    });\n\n### Transaction.adapter\n\nContains the adapter name used for this transaction, e.g. `'sqlite3'`, etc.\n\n### Transaction events\n\n * `'query', query` - emitted immediately after `.query` is called on a\n   connection via `tx.query`. The argument is a [query](#query) object.\n * `'commit:start'`      - Emitted when `.commit()` is called.\n * `'commit:complete'`   - Emitted after the transaction has committed.\n * `'rollback:start'`    - Emitted when `.rollback()` is called.\n * `'rollback:complete'` - Emitted after the transaction has rolled back.\n * `'close'`             - Emitted after `rollback` or `commit` completes.\n * `'error', err`        - Emitted under three conditions:\n   1. There was an error acquiring a connection.\n   2. Any query performed in this transaction emits an error that would otherwise\n      go unhandled.\n   3. Any of `query`, `begin`, `commit`, or `rollback` are called after the\n      connection has already been committed or rolled back.\n\n   Note that the `'error'` event **may be emitted multiple times!** depending on\n   the callback you are registering, you way want to wrap it using [once][once].\n\n### Transaction Example\n\nHere's an example where we stream all of our user ids, check them against an\nexternal abuse-monitoring service, and flag or delete users as necessary, if\nfor any reason we only get part way through, the entire transaction is rolled\nback and nobody is flagged or deleted:\n\n\tvar tx = pool.begin()\n\n\ttx.on('error', finished)\n\n\t/*\n\tWhy query with the pool and not the transaction?\n\tBecause it allows the transaction queries to begin executing immediately,\n\trather than queueing them all up behind the initial SELECT.\n\t*/\n\tpool.query('SELECT id FROM users').on('row', function (user) {\n\t\tif (tx.state().match('rollback')) return\n\t\tabuseService.checkUser(user.id, function (err, result) {\n\t\t\tif (err) return tx.handleError(err)\n\t\t\t// Errors from these queries will propagate up to the transaction object\n\t\t\tif (result.flag) {\n\t\t\t\ttx.query('UPDATE users SET abuse_flag = 1 WHERE id = $1', [user.id])\n\t\t\t} else if (result.destroy) {\n\t\t\t\ttx.query('DELETE FROM users WHERE id = $1', [user.id])\n\t\t\t}\n\t\t})\n\t}).on('error', function (err) {\n\t\ttx.handleError(err)\n\t}).on('end', function () {\n\t\ttx.commit(finished)\n\t})\n\n\tfunction finished (err) {\n\t\tif (err) console.error(err)\n\t\telse console.log('All done!')\n\t}\n\n# License\n\n2-clause BSD\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/grncdr/node-any-db-transaction",
  "_id": "any-db-transaction@0.0.1",
  "_from": "any-db-transaction@~0.0.1"
}
